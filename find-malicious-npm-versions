#!/usr/bin/env node

import { createReadStream } from 'node:fs';
import { createInterface } from 'node:readline';
import { spawn } from 'node:child_process';

async function parsePackages(filename) {
  const packageArray = [];
  try {
    const fileStream = createReadStream(filename);
    const rl = createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    for await (const line of rl) {
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const atIndex = trimmedLine.lastIndexOf('@');
        if (atIndex > 0) {
          const packageName = trimmedLine.substring(0, atIndex);
          const packageVersion = trimmedLine.substring(atIndex + 1);
          packageArray.push([packageName, packageVersion]);
        } else {
          console.warn(`Ungültiges Format in Zeile (wird ignoriert): ${trimmedLine}`);
        }
      }
    }
    return packageArray;
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.error(`Fehler: Datei nicht gefunden - "${filename}"`);
    } else {
      console.error(`Ein Fehler ist aufgetreten: ${error.message}`);
    }
    process.exit(1);
  }
}

function searchInFile(packageName, packageVersion, filename) {
  return new Promise((resolve, reject) => {
    const grep = spawn('grep', ['-Hn', '-E', `${packageName}.*${packageVersion}`, filename]);

    let output = '';
    let errorOutput = '';

    grep.stdout.on('data', (data) => {
      output += data.toString();
    });

    grep.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    grep.on('close', (code) => {
      if (code === 0) {
        resolve(output.trim());
      } else if (code === 1) {
        resolve(null); // Kein Treffer gefunden
      } else {
        reject(new Error(`grep Prozess endete mit Code ${code}: ${errorOutput.trim()}`));
      }
    });
  });
}

async function main() {
  const args = process.argv.slice(2);
  const verbose = args[0] === '-v' || args[0] === '--verbose';
  const primaryFile = args[verbose ? 1 : 0];
  const childProcessFiles = args.slice(verbose ? 2 : 1);

  function showHelp() {
    console.log(`
Verwendung: node <Skriptname.js> [ -v ] <Haupt-Dateiname> [<weitere-Dateinamen>...]

Liest eine Datei ein und parst diese zeilenweise als NPM-Paket-Namen mit Version im Format "packageName@1.1.0".
Sucht anschließend diese NPM Versionen innerhalb jeder weiteren angegebenen Datei.

Argumente:
  <Haupt-Dateiname>       Pfad zur Haupttextdatei.
  <weitere-Dateinamen>... Eine oder mehrere zusätzliche Dateien, idealerweise package.json files, die durchsucht werden sollen.

Optionen:
  -v, --verbose           Aktiviert ausführliche Ausgabe.
  -h, --help              Zeigt diese Hilfe an.

Beispiel:
  $ find . -name package.json | xargs node find-malicious-npm-versions.js malicious-packages.txt

  packages.txt:
    backslash@0.2.1
    chalk@5.6.1
    proto-tinker-wc@1.8.7
`);
    process.exit(0);
  }

  if (!primaryFile || childProcessFiles.length === 0 | args.includes('-h') || args.includes('--help')) {
    showHelp();
  }

  const packages = await parsePackages(primaryFile);

  if (verbose) {
    console.error(`\nLese NPM Versions Datei: ${primaryFile}`);
    console.error('Gefundene Paket-Namen und Version:', packages);
  }

  // Child-Prozesse starten
  if (childProcessFiles.length > 0 && packages.length > 0) {
    for (const [packageName, packageVersion] of packages) {
      const version = packageVersion.endsWith('*') ? packageVersion.split('.').slice(0, 2).join('.') : packageVersion;

      const results = (await Promise.all(
        childProcessFiles.map((file) => searchInFile(packageName, version, file))
      )).filter(Boolean);

      if (results.length > 0) {
        if (verbose) {
          console.error(`\n++ Gefundenes Paket: ${packageName}@${version}`);
        }

        results.forEach((result) => {
          console.log(result);
        });
      } else if (verbose) {
        console.error(`\n-- Kein Treffer für Paket: ${packageName}@${version}`);
      }
    }
  }
}

main();

// vim:ft=js:
